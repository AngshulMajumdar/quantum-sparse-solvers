# -*- coding: utf-8 -*-
"""QIRLS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PSfV1mJIEg95ttN5qZ77kaJkiASSNiF6
"""

# Block 1: Environment sanity & determinism

import numpy as np
import sys

# Determinism
np.random.seed(42)

print("Python version:", sys.version.split()[0])
print("NumPy version:", np.__version__)

# Simple deterministic check
x = np.random.randn(5)
print("Deterministic vector:", x)

# Block 2: Sparse regression problem generator

import numpy as np

def generate_sparse_problem(
    m=40,
    n=60,
    sparsity=6,
    noise_std=1e-2,
    seed=42
):
    rng = np.random.default_rng(seed)

    A = rng.standard_normal((m, n)) / np.sqrt(m)

    x_true = np.zeros(n)
    support = rng.choice(n, size=sparsity, replace=False)
    x_true[support] = rng.standard_normal(sparsity)

    noise = noise_std * rng.standard_normal(m)
    b = A @ x_true + noise

    return A, b, x_true, support


# Generate problem
A, b, x_true, support = generate_sparse_problem()

print("A shape:", A.shape)
print("b shape:", b.shape)
print("True sparsity:", np.count_nonzero(x_true))
print("Support indices:", support)
print("First 5 entries of b:", b[:5])

# Block 3: Quantum linear solver interface (Qiskit-backed)

import numpy as np

try:
    from qiskit import Aer
    from qiskit.utils import QuantumInstance
    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False


class QuantumLinearSolver:
    """
    Hybrid quantum–classical linear solver.
    Uses Qiskit backends when available.
    """

    def __init__(self, backend_name="aer_simulator"):
        self.backend_name = backend_name

        if QISKIT_AVAILABLE:
            self.backend = Aer.get_backend(backend_name)
            self.qi = QuantumInstance(self.backend)
        else:
            self.backend = None
            self.qi = None

    def solve(self, M, y):
        """
        Solve M x = y.
        Quantum hook goes here.
        """
        # For now: deterministic classical fallback
        return np.linalg.solve(M, y)


# Sanity test
solver = QuantumLinearSolver()
print("Qiskit available:", QISKIT_AVAILABLE)

# Tiny test system
M_test = np.array([[2.0, 0.0], [0.0, 1.0]])
y_test = np.array([1.0, 3.0])

x_test = solver.solve(M_test, y_test)
print("Linear solve result:", x_test)

# Block 4: Classical IRLS core (quantum-ready)

import numpy as np

def update_weights(x, eps):
    """
    Diagonal IRLS weights for l1 approximation.
    """
    return 1.0 / (np.abs(x) + eps)


def irls_solve(
    A,
    b,
    lam=0.1,
    eps=1e-3,
    max_iter=20,
    tol=1e-6,
    solver=None
):
    """
    Iteratively Reweighted Least Squares (IRLS)
    with pluggable linear solver (classical or quantum).
    """
    m, n = A.shape
    x = np.ones(n)

    AtA = A.T @ A
    Atb = A.T @ b

    for k in range(max_iter):
        w = update_weights(x, eps)
        W = np.diag(w)

        M = AtA + lam * W

        # Hybrid solve
        if solver is None:
            x_new = np.linalg.solve(M, Atb)
        else:
            x_new = solver.solve(M, Atb)

        # Convergence check
        rel_change = np.linalg.norm(x_new - x) / (np.linalg.norm(x) + 1e-12)
        print(f"IRLS iter {k:02d} | rel_change = {rel_change:.3e}")

        if rel_change < tol:
            break

        x = x_new

    return x


# Test IRLS on previously generated problem
x_irls = irls_solve(A, b, lam=0.1)

print("\nRecovered sparsity:", np.count_nonzero(np.abs(x_irls) > 1e-3))
print("Recovered x (first 10 entries):", x_irls[:10])

# Block 5: IRLS with epsilon continuation (production-grade)

import numpy as np

def irls_solve_continuation(
    A,
    b,
    lam=0.1,
    eps_init=1e-1,
    eps_final=1e-4,
    eps_decay=0.5,
    max_iter=20,
    tol=1e-6,
    solver=None
):
    m, n = A.shape
    x = np.zeros(n)

    AtA = A.T @ A
    Atb = A.T @ b

    eps = eps_init

    while eps >= eps_final:
        print(f"\n=== IRLS stage | eps = {eps:.1e} ===")

        for k in range(max_iter):
            w = 1.0 / (np.abs(x) + eps)
            W = np.diag(w)

            M = AtA + lam * W

            if solver is None:
                x_new = np.linalg.solve(M, Atb)
            else:
                x_new = solver.solve(M, Atb)

            rel_change = np.linalg.norm(x_new - x) / (np.linalg.norm(x) + 1e-12)
            print(f"  iter {k:02d} | rel_change = {rel_change:.3e}")

            if rel_change < tol:
                break

            x = x_new

        eps *= eps_decay

    return x


# Run continuation IRLS
x_irls_cont = irls_solve_continuation(A, b, lam=0.1)

print("\nRecovered sparsity:",
      np.count_nonzero(np.abs(x_irls_cont) > 1e-3))
print("Recovered x (first 10 entries):",
      x_irls_cont[:10])

# Block 6 (fixed): Verify Qiskit Aer with modern API

from qiskit_aer import AerSimulator
from qiskit import QuantumCircuit

# Create a simple test circuit
qc = QuantumCircuit(1)
qc.h(0)
qc.measure_all()

backend = AerSimulator()
result = backend.run(qc, shots=100).result()
counts = result.get_counts()

print("Qiskit Aer simulator working")
print("Measurement counts:", counts)

# Block 7.1: Install qiskit-algorithms (required for HHL)

import sys
import subprocess

subprocess.check_call([
    sys.executable, "-m", "pip", "install", "qiskit-algorithms"
])

print("qiskit-algorithms installed")

# Block 7 (final): Pure quantum linear solver using HHL
# NOTE: Requires qiskit-algorithms + SciPy compatible with NumPy < 2.0

import numpy as np
from qiskit.quantum_info import Statevector


class QuantumLinearSolverHHL:
    """
    Pure quantum linear solver based on HHL.

    Conceptual operation:
        |x> ∝ M^{-1} |y>

    This implementation mirrors textbook HHL.
    Execution requires a compatible SciPy / NumPy stack.
    """

    def __init__(self):
        # Import locally to avoid hard dependency breakage
        from qiskit_algorithms.linear_solvers import HHL
        self.hhl = HHL()

    def solve(self, M, y):
        """
        Solve M x = y using HHL.

        Returns a classical approximation of x
        extracted from the output quantum state.
        """
        y_norm = np.linalg.norm(y)
        if y_norm == 0:
            raise ValueError("Right-hand side vector is zero.")

        y_normalized = y / y_norm

        result = self.hhl.solve(M, y_normalized)

        state = result.state
        if not isinstance(state, Statevector):
            raise RuntimeError("Unexpected HHL output type")

        x_quantum = np.real(state.data)
        return y_norm * x_quantum

# Block 8: Pure Quantum IRLS loop (textbook form)

import numpy as np


def quantum_irls(
    A,
    b,
    lam=0.1,
    eps_init=1e-1,
    eps_final=1e-4,
    eps_decay=0.5,
    max_iter=10
):
    """
    Quantum Iteratively Reweighted Least Squares (IRLS).

    At each iteration:
        M^(k) = A^T A + lambda * W^(k)
        x^(k+1) = M^(k)^{-1} A^T b   (via HHL)

    Weight update is classical.
    Linear solve is quantum.
    """

    m, n = A.shape
    x = np.zeros(n)

    AtA = A.T @ A
    Atb = A.T @ b

    # Quantum linear solver (HHL)
    solver = QuantumLinearSolverHHL()

    eps = eps_init
    while eps >= eps_final:
        for k in range(max_iter):
            # IRLS weights
            W = np.diag(1.0 / (np.abs(x) + eps))

            # System matrix
            M = AtA + lam * W

            # Quantum linear solve
            x = solver.solve(M, Atb)

        eps *= eps_decay

    return x