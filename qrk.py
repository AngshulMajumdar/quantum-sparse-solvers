# -*- coding: utf-8 -*-
"""QRK.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iX4MCh0SscJDbFpIP0-ky8vT55Ae4mH2
"""

# Q-RK Block 1: Classical Randomized Kaczmarz (pure ISTA-style)

import numpy as np


def randomized_kaczmarz(A, b, num_iters=100):
    """
    Classical Randomized Kaczmarz method.

    Solves Ax = b via row projections.
    """
    m, n = A.shape
    x = np.zeros(n)

    # Row selection probabilities
    row_norms = np.sum(A**2, axis=1)
    probs = row_norms / np.sum(row_norms)

    for _ in range(num_iters):
        i = np.random.choice(m, p=probs)
        a_i = A[i]
        b_i = b[i]

        residual = b_i - np.dot(a_i, x)
        x = x + (residual / row_norms[i]) * a_i

    return x

# Q-RK Block 2: Weighted Randomized Kaczmarz (IRLS-aware, pure)

import numpy as np


def weighted_randomized_kaczmarz(A, b, w, num_iters=100):
    """
    Weighted Randomized Kaczmarz method.

    Solves Ax = b with diagonal weight matrix W = diag(w),
    typically coming from IRLS.
    """
    m, n = A.shape
    x = np.zeros(n)

    W_inv = np.diag(1.0 / w)

    # Weighted row norms for sampling
    row_norms = np.array([
        A[i] @ W_inv @ A[i] for i in range(m)
    ])
    probs = row_norms / np.sum(row_norms)

    for _ in range(num_iters):
        i = np.random.choice(m, p=probs)
        a_i = A[i]
        b_i = b[i]

        residual = b_i - np.dot(a_i, x)
        x = x + (residual / row_norms[i]) * (W_inv @ a_i)

    return x

# Q-RK Block 3: Quantum Inner Product Estimation (pure, conceptual)

import numpy as np


class QuantumInnerProductEstimator:
    """
    Pure quantum inner product estimation.

    Conceptual operation:
        Given |u>, |v>, estimate <u | v>

    Assumes amplitude encoding.
    """

    def estimate(self, u, v):
        """
        Estimate inner product <u, v> using a quantum routine.

        This is a conceptual placeholder for:
        - Hadamard test
        - Swap test
        - Amplitude estimation

        Returns a scalar estimate.
        """
        # Conceptual: quantum routine returns <u|v>
        # Classical dot used only as mathematical stand-in
        return np.dot(u, v)

# Q-RK Block 4: Pure Quantum Randomized Kaczmarz (canonical form)

import numpy as np


def quantum_randomized_kaczmarz(A, b, num_iters=100):
    """
    Pure Quantum Randomized Kaczmarz method.

    Classical:
        - row sampling
        - state update

    Quantum:
        - inner product estimation <a_i, x_k>
    """
    m, n = A.shape
    x = np.zeros(n)

    # Quantum inner product estimator
    qip = QuantumInnerProductEstimator()

    # Sampling distribution
    row_norms = np.sum(A**2, axis=1)
    probs = row_norms / np.sum(row_norms)

    for _ in range(num_iters):
        i = np.random.choice(m, p=probs)
        a_i = A[i]
        b_i = b[i]

        # Quantum-estimated inner product
        ai_x = qip.estimate(a_i, x)

        residual = b_i - ai_x
        x = x + (residual / row_norms[i]) * a_i

    return x