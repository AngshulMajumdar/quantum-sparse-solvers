# -*- coding: utf-8 -*-
"""QOMP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U1olm8jb8VL9cj_OifrpC28qnIp7yJfL
"""

# Q-OLS Block 1: Quantum Residual-Norm Oracle (canonical)

import numpy as np


class QuantumResidualNormOracle:
    """
    Pure quantum oracle for residual-norm evaluation.

    Conceptual task:
        For a candidate atom a_j, estimate
            || P_{Lambda ∪ {j}}^⊥ b ||_2

    Assumes:
        - quantum projection via block-encoding / HHL / QSVT
        - quantum norm (amplitude) estimation
    """

    def estimate(self, A_support, a_j, b):
        """
        Estimate residual norm after adding atom a_j
        to the current support.

        Classical least-squares is used only as a
        mathematical stand-in.
        """
        if A_support is None or A_support.size == 0:
            A_ext = a_j.reshape(-1, 1)
        else:
            A_ext = np.column_stack([A_support, a_j])

        # Projection onto span(A_ext)
        x_hat = np.linalg.lstsq(A_ext, b, rcond=None)[0]
        residual = b - A_ext @ x_hat

        return np.linalg.norm(residual)

# Q-OLS Block 2: Pure Quantum Orthogonal Least Squares (canonical)

import numpy as np


def quantum_ols(A, b, sparsity):
    """
    Pure Quantum Orthogonal Least Squares (Q-OLS).

    Quantum:
        - residual-norm evaluation for greedy selection

    Classical:
        - least squares on active set
        - residual update
    """
    m, n = A.shape
    support = []
    x = np.zeros(n)

    # Quantum residual-norm oracle
    qoracle = QuantumResidualNormOracle()

    for _ in range(sparsity):
        best_j = None
        best_norm = np.inf

        A_s = A[:, support] if len(support) > 0 else None

        # Quantum greedy selection (global criterion)
        for j in range(n):
            if j in support:
                continue

            a_j = A[:, j]
            res_norm = qoracle.estimate(A_s, a_j, b)

            if res_norm < best_norm:
                best_norm = res_norm
                best_j = j

        support.append(best_j)

        # Classical least squares on active set
        A_s = A[:, support]
        x_s = np.linalg.lstsq(A_s, b, rcond=None)[0]

    x[support] = x_s
    return x